# IDEAS.md — копилка идей DocOrchestrator

Этот файл — список идей, гипотез и будущих улучшений, которые всплывали в обсуждениях, но не обязательно реализуются в ближайшем MVP.

## Легенда

- **Статус**: idea (идея), planned (запланировано), later (позже), research (исследование), maybe (под вопросом).
- **Цель**: зачем идея нужна (качество, скорость, надежность, удобство).
- **Риск**: что может пойти не так.

---

## 1) Маршрутизация, фазы, планировщик

### 1.1 Фазовый прогон моделей (batch-by-stage)

**Статус**: later  
**Цель**: не держать быструю и старшую модель одновременно; прогонять документы «волнами» (сначала все router, затем все extract) для слабого железа.  
**Идея**:

- Фаза A: загрузить быструю модель (router) → прогнать классификацию/детектор → выгрузить.
- Фаза B: загрузить старшую модель (extractor) → прогнать preprocess/split/extract → выгрузить.

### 1.2 Эвристика small-batch: пропуск fast-роутера

**Статус**: later  
**Цель**: если документов мало (2–3), то выгоднее сразу грузить старшую модель, чем тратить время на загрузку/перегрузку быстрой.  
**Замечание**: критерии small-batch (по docCount/pageCount) должны быть конфигурируемыми.

### 1.3 Ветвление пайплайна по docType

**Статус**: planned  
**Цель**: по-разному обрабатывать разные типы документов (DPI, preprocessing, модель, ретраи).

---

## 2) DPI и «пирамида разрешений»

### 2.1 Пирамида DPI (75/100/150/200/250/300) на этапе разработки

**Статус**: research  
**Цель**: найти «точку перегиба» — минимальный DPI, дающий 100% точность для конкретного docType (ускорение в разы).  
**Идея**: растеризовать сразу несколько DPI и сохранять артефакты, чтобы прогонять извлечение/валидацию на каждом.

**Примечание**: 75 dpi добавляется сначала только для тестирования (гипотеза: его может хватить для определения типа документа).  
Если подтвердится — перенести в прод как DPI по умолчанию для router (с fallback).

### 2.1.1 75 DPI для Router: тест → возможный прод

**Статус**: research  
**Цель**: ускорить определение типа документа и уменьшить IO/размер артефактов на слабом железе.  
**Идея**:
- Router пытается классифицировать по `r75/p1.webp`.
- Если ответ “плохой” (неизвестный тип / низкая уверенность / не проходит пост-проверки) — fallback на `r100` или `r150`.

**Риск**: на документах с мелким текстом и/или плохим сканом 75 DPI может “убить” отличительные признаки.

### 2.2 Выбор DPI по типу документа

**Статус**: planned  
**Цель**: простые типы документов (или крупный шрифт) часто можно стабильно извлекать на 100–150 DPI, экономя время и VRAM.  
**Идея**: в `docTypes/*.json` хранить `preferred_dpi` и fallback-стратегию (например 150 → 200 → 300 при провале валидации).

---

## 3) Предобработка изображений

### 3.1 Отдельная стадия Preprocess/Enhancer

**Статус**: later  
**Цель**: поднять точность распознавания (особенно на шумных сканах) при относительно дешевой CPU-стоимости по сравнению с VLM.  
**Кандидаты-операции**:

- deskew/поворот/выравнивание;
- усиление контраста/нормализация;
- шумоподавление;
- (опционально) бинаризация для «мелкого текста».

### 3.1.1 Каскадный deskew: VLM + CV

**Статус**: research  
**Цель**: повысить стабильность ориентации и читаемости небольших документов (паспорт, ВУ, СТС и т.п.), особенно для мелкого текста (VIN, номера).  
**Идея**:

- Быстрая VLM (router) грубо определяет поворот документа (0/90/180/270 градусов).
- Изображение поворачивается до «правильной» стороны.
- Классическая CV-библиотека (например, OpenCV) дорабатывает небольшой наклон (±5°) с помощью алгоритма deskew.
- Для сложных случаев (сильные перспективные искажения) возможен отдельный режим «aggressive deskew».

**Риск**: дополнительные вычисления; требуется аккуратная калибровка, чтобы не портить уже ровные изображения и не вносить артефакты.

### 3.2 Скоринг качества изображения и авто-режимы

**Статус**: research  
**Цель**: автоматически определять «плохие» изображения и выбирать агрессивную предобработку.  
**Идея**: вычислять метрики резкости/энтропии/контраста и по порогам выбирать режим.

### 3.3 Несколько режимов предобработки + выбор лучшего

**Статус**: later  
**Цель**: в тестовом/«ночном» режиме прогонять несколько вариантов (raw, contrast, denoise, deskew…) и выбирать лучший по валидации и/или по метрикам качества.  
**Замечание**: это особенно полезно, когда время не критично, а точность важнее.

---

## 4) Assemble входа (канонизация)

### 4.1 Сборка «входного документа» в 1 PDF до растрирования

**Статус**: planned  
**Цель**: привести вход к единообразному виду “1 документ = 1 PDF (1..N страниц)” перед rasterize/classify/extract.  
**Идея**:
- Если вход: несколько PDF → склеить “как есть” в один PDF (страницы последовательно).
- Если вход: набор изображений → собрать “как есть” в один PDF (страницы последовательно).
- Использовать именно входные файлы (не отрастрированные картинки), чтобы максимально сохранить соответствие оригиналу.
- Сохранять список `sources[]` (пути/имена исходных файлов) в метаданных документа.

**Риски**:
- Нужны правила сортировки файлов внутри папки документа.
- Встречаются “битые”/защищённые PDF (нужно решать, что делать при ошибке сборки).
- Порядок страниц критичен для смысла документа.

**Тех. заметка** (варианты реализации): poppler `pdfunite`, `qpdf` или Node-библиотека (pdf-lib и аналоги).  

---

## 5) Split/Segmenter (совмещенные документы)

### 5.1 Детектор «комбо-сканов» на ранней фазе

**Статус**: later  
**Цель**: определять, что на одном листе несколько документов.

### 5.2 Splitter: bbox → нарезка → новые под-документы

**Статус**: later  
**Цель**: поддержка листов, где несколько документов (паспорт+ВУ и т.п.) с преобразованием одного листа в несколько отдельных сущностей документа.  
**Идея**: VLM возвращает bbox; библиотека обработки изображений режет; оркестратор кладет sub-docs в staging и прогоняет их как обычные документы.

---

## 6) Точность, проверка, ретраи

### 6.1 Валидация/нормализация/верификация кодом (domain rules)

**Статус**: planned  
**Цель**: качество данных достигается не только моделью, но и детерминированными правилами.  
**Примеры**:

- форматы дат, паспортных серий/номеров;
- контрольные суммы/доменные проверки (где применимо);
- согласованность полей (например, дата выдачи не позже текущей).

### 6.2 Повторный запрос модели (retry) при провале валидации

**Статус**: planned  
**Цель**: «дожимать» результат до корректного JSON и повышать точность без ручного вмешательства.  
**Идея**: валидатор формирует короткий "fix prompt": «Исправь только поля X/Y, формат такой-то, JSON-only».

### 6.3 Таблица типичных OCR/VLM-ошибок + автопатчи

**Статус**: later  
**Цель**: исправлять типичные путаницы символов (O/0, I/1, В/8…) только при провале валидации и только в релевантных полях.

---

## 7) Референсы, тестирование, регрессии

### 7.1 Ground Truth dataset + автоматическая оценка (Evaluator)

**Статус**: planned  
**Цель**: измеримость, борьба «за каждый процент» и защита от регрессий при смене модели/промпта/предобработки.

### 7.2 Матрица экспериментов: модели × DPI × preprocess × промпты

**Статус**: research  
**Цель**: комплексно сравнивать варианты и выбирать оптимальные профили под каждый docType.  
**Идея**: запускать сериями и сохранять таблицы результатов (accuracy, время, причины ошибок).

### 7.3 Бенчмарк не только точности, но и времени на каждом шаге

**Статус**: planned  
**Цель**: оптимизация под слабые ПК (1060/FX и т.п.) требует точной картины, где тратится время.  
**Идея**: тайминг каждого атома + агрегаты по документу/типу/модели/DPI.

---

## 8) Хранилище и экспорт (JSON-first)

### 8.1 JSON как единое хранилище конфигов и артефактов

**Статус**: planned  
**Цель**: простота, переносимость, кэшируемость, отсутствие зависимости от БД.

### 8.2 Атомарная запись JSON, версия схем, миграции

**Статус**: later  
**Цель**: надежность при падениях/прерываниях и аккуратное изменение форматов конфигов/артефактов.

### 8.3 Плоская выходная папка: PDF + общий JSON

**Статус**: planned  
**Цель**: выход — одна папка, в которой лежат:
- все переименованные PDF (по одному PDF на документ);
- один общий JSON на всю пачку (для интеграции).

**Идея**:
- В JSON у каждого документа есть поле-ссылка на PDF (имя файла/относительный путь), лежащий в этой же папке.
- Документы не раскладываются по подпапкам на выходе (всё рядом).

### 8.4 Говорящее имя файла + антиколлизия

**Статус**: planned  
**Цель**: человек “одним взглядом” понимает, что это за документ, и не путает с соседними.  
**Идея**:
- База имени: `<DocTypeName>_<KeyHumanReadable>`.
- Антиколлизия: суффикс `__YYYY-MM-DD` и/или `__NNN` и/или `__<shortDocId>`.
- Санитизация имени (недопустимые символы, длина, пробелы).

**Примеры** (наброски):
- `Паспорт_ИвановИИ_4510-123456__2025-12-25__001.pdf`
- `ЕГРЮЛ_ООО_Ромашка_ИНН7701...__2025-12-25__002.pdf`

**Риски**:
- ПДн в именах файлов (нужно явно решить допустимость и правила маскирования/обрезки).
- Коллизии даже “говорящих” имен (одинаковые ФИО/номер, разные документы).

---

## 9) UI/админка (когда созреет)

### 9.1 Админка для управления конфигами и прогонами

**Статус**: maybe  
**Цель**: удобная настройка без ручного редактирования JSON, запуск тестов, сравнение профилей.

---

## 10) Производительность и «слабое железо»

### 10.1 Дизайн под GTX 1060 6Gb / AMD FX / DDR3

**Статус**: planned  
**Цель**: система должна оставаться полезной даже на слабом железе, пусть и медленнее.  
**Направления**:

- строгая фазовость (не держать две модели);
- минимум лишних проходов по диску;
- кэширование артефактов (не пересчитывать при повторе);
- лимиты параллелизма для CPU-стадий.

---

## 11) Типы документов и предметная область

### 11.1 Поддержка юридических выписок (ЕГРЮЛ/ЕГРИП/ЕГРН) под кейсы должников

**Статус**: planned  
**Цель**: извлечение сущностей/полей из сложных многостраничных документов.  
**Идея**: docType-конфиги должны описывать поля, подсказки и правила верификации.

---

## 12) Модели и стратегия выбора

### 12.1 Сравнение моделей и режимов (fast router + heavy extractor)

**Статус**: planned  
**Цель**: держать возможность тестировать разные модели и выбирать победителей по метрикам точности/скорости.  
**Замечание**: конечная база определяется эмпирически (Evaluator + time).
